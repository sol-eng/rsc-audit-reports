---
title: "Content Distribution List Compliance Audit"
output: 
  html_document:
    theme: lumen
    code_folding: hide
rmd_output_metadata:
  rsc_output_files:
    - "compliance_check_fail.csv"
---

`r if(Sys.getenv('CONNECT_SERVER') == '') { "<h4>ERROR: You must set the CONNECT_SERVER environment variable</h4>\n" }` 
`r if(Sys.getenv('USER_INFO_PIN') == '') { "<h4>ERROR: You must set the USER_INFO_PIN environment variable ex. 'username/user-info'</h4>\n" }` 
`r if(Sys.getenv('GROUP_INFO_PIN') == '') { "<h4>ERROR: You must set the GROUP_INFO_PIN environment variable ex. 'username/group-info'</h4>\n" }` 
`r if(Sys.getenv('ACL_USERS_PIN') == '') { "<h4>ERROR: You must set the ACL_USERS_PIN environment variable ex. 'username/acl-users-table'</h4>\n" }`
`r if(Sys.getenv('ACL_GROUPS_PIN') == '') { "<h4>ERROR: You must set the ACL_GROUPS_PIN environment variable ex. 'username/acl-groups-table'</h4>\n" }` 
`r if(Sys.getenv('CONNECT_API_KEY') == '') { "<h4>ERROR: You must set the CONNECT_API_KEY environment variable</h4>\n" }` 
`r if(Sys.getenv('CONNECT_API_KEY') == '' || Sys.getenv('CONNECT_SERVER') == '') { knitr::knit_exit() }`

Motivation: many organizations have groups of users organized by line of business, or some other grouping. As as result, there are times when you do not want users within those groups to see each other's content that they publish to RStudio Connect. Today there are two solutions for this scenario. One, you can manage a separate instance of Connect for each business unit likely using an RStudio Connect Enteprise license. Two, you can audit content that is published on RStudio Connect and receive an automated report warning you. This document will walk through the second solution and in particular shows you how to first detect, and then receive an alert if a user belonging to one business unit adds a user or batch of users from another business unit to their content Access Control List ("ACL").

Step 1: Decide how to configure **Most Permissive Access Type** restrictions for Publishers and Admins (globally) on the Server. This will determine whether all access levels are necessary to track in this report. Read more about 'Most Permissive Access Type' configuration options in the [Admin Guide](https://docs.rstudio.com/connect/admin/appendix/configuration/#Applications.MostPermissiveAccessType).

### Get Pins

For each content item shared with specific users or groups, report the user/group and list whether they have viewer or collaborator access.

- `acl-users-table` a pin for all content permissions that have been explicitly shared with other (specific) users.
- `acl-groups-table` a pin for all content items that have been explicitly shared with specific groups.

These pins can be generated by running `acl-pin-generator.Rmd` (intended to be run on a schedule). 

```{r}
# Register RStudio Connect
library(pins)
board_register("rsconnect", server = Sys.getenv('CONNECT_SERVER'))

# Get the acl-users-table Pin
users_table <- pin_get(name = Sys.getenv("ACL_USERS_PIN"), board = "rsconnect")

# Get the acl-groups-table Pin
groups_table <- pin_get(name = Sys.getenv("ACL_GROUPS_PIN"), board = "rsconnect")
```

### Get group memberbership details

**Warning: Group member enumeration is currently not supported for LDAP.**

This function is available only when groups are enabled in RStudio Connect and only for Password, PAM, OAuth2, SAML and Proxied authentication. The `email` field is not populated for non-admins when `Server.HideEmailAddresses` is enabled. [Read More](https://docs.rstudio.com/connect/api/#get-/v1/groups/%7Bgroup_guid%7D/members)

```{r message=FALSE, warning=FALSE}
library(tibble)
library(httr)
library(dplyr)
# Function for initializing an empty membership tibble
empty_membership <- function() {
  cols <- c('group_guid','email','username','user_role','user_guid')
  cols %>% purrr::map_dfc(setNames, object = list(character()))
}
# Function for calling the content `/groups/{guid}/members` API endpoint
# This endpoint gets the group member details
# WARNING! Group member enumeration is currently not supported for LDAP
member_details <- function(group_guid){
  membership <- GET(paste0(Sys.getenv("CONNECT_SERVER"),"__api__/v1/groups/",group_guid,"/members"),
    add_headers(Authorization = paste("Key", Sys.getenv("CONNECT_API_KEY"))))
  if (status_code(membership) == 200){
    result <- tidyr::unnest_wider(tibble::tibble(dat = content(membership)$result), dat)
    if (dim(result)[1] == 0){
      empty_membership() 
    } else {
      result %>%
        add_column(group_guid = group_guid) %>%
        select(group_guid, email, username, user_role, guid) %>%
        rename(user_guid = guid)
    }
  } else {
    empty_membership()
  }
}

# Get the group info Pin
group_info <- pin_get(name = Sys.getenv("GROUP_INFO_PIN"), board = "rsconnect")

# Get membership details for all groups
group_info <- purrr::map(group_info$guid, member_details)
membership_tibble <- tidyr::unnest(tibble::tibble(dat = group_info), dat)
```


### Create group membership lookup tables

- Create a lookup table of content owner group memberships
- Create a lookup table of content viewer/collaborator (principal) group memberships

```{r message=FALSE, warning=FALSE}

# Distinct content owner guids
groups_table_owners <- groups_table %>%
  distinct(content_owner)

users_table_owners <- users_table %>%
  distinct(content_owner)

content_owners <- rbind(users_table_owners, groups_table_owners) %>%
  distinct(content_owner)

# Function to return group memberships list given a user guid
find_memberships <- function(user){
  mships <- membership_tibble %>%
    filter(user_guid == user) %>%
    select(group_guid)
  
  if (dim(mships)[1] == 0){
      tibble(user_guid = user, groups = NA)
    } else {
      tibble(user_guid = user, groups = mships$group_guid)
    }
}

# Create a lookup table of content owner memberships
owner_info <- purrr::map(content_owners$content_owner, find_memberships)
owner_mships <- tidyr::unnest(tibble::tibble(dat = owner_info), dat)

# Distinct viewer/collaborators list
users_table_principals <- users_table %>%
  distinct(principal_guid)

# Create a lookup table of content viewer/collaborator (principal) memberships
principal_info <- purrr::map(users_table_principals$principal_guid, find_memberships)
principal_mships <- tidyr::unnest(tibble::tibble(dat = principal_info), dat)
```

## Group Membership Check: Owner/Publisher & Principal=Group

Check whether the owner/publisher belongs to the same group(s) they've added to the Access Control List (given content access to). 

```{r compliance-check}
# groups_table owner_mships
groups_table_pass <- inner_join(groups_table, owner_mships, by=c("content_owner" = "user_guid", "principal_guid" = "groups"))

groups_table_fail <- anti_join(groups_table, owner_mships, by=c("owner_guid" = "user_guid", "principal_guid" = "groups"))
```

- **Content items passing compliance check:** `r nrow(groups_table_pass)`
- **Content items failing compliance check:** `r nrow(groups_table_fail)`

### Preview Table: Content failing compliance check

```{r audit-failure}
# Get user info pin
user_info <- pin_get(name = Sys.getenv("USER_INFO_PIN"), board = "rsconnect")

compliance_fail <- groups_table_fail %>%
  left_join(user_info, by=c('content_owner' = 'guid')) %>%
  select(content_guid, content_owner, name.x, title, dashboard_url, username, email)

library(reactable)
# Display reactable for all items failing the compliance check
preview_table <- compliance_fail %>%
  reactable(searchable = TRUE, highlight = TRUE, columns = list(
    content_guid = colDef(name = "Content GUID"),
    content_owner = colDef(name = "Owner GUID"),
    name.x = colDef(name = "Name"),
    title = colDef(name = "Title"),
    dashboard_url = colDef(name = "Content URL", cell = function(value) {
    htmltools::tags$a(href = value, target = "_blank", "Link")
    }),
    username = colDef(name = "Username"),
    email = colDef(name = "Email")
  ))

preview_table
```

## TODO: Group Membership Check: Owner/Publisher & Principal=User

- Check whether the owner/publisher belongs to the same group(s) as the user(s) they've added to the Access Control List (given content access to).


## Download the full compliance report contents

```{r include=FALSE}
# Write the compliance_check_fail response out to a CSV file for download
write.csv(compliance_fail, "compliance-failures.csv", row.names=FALSE)
```

-   Report: [compliance-failures.csv](compliance-failures.csv)

```{r connect_email, echo=FALSE}
library(blastula)
# Send an email alert if content items fail compliance check
if (nrow(compliance_fail) > 0) {
  render_connect_email(input = "alert.Rmd") %>%
    attach_connect_email(
      subject = "RStudio Connect Content ACL Compliance Alert"
    )
} else {
  suppress_scheduled_email()
}
```